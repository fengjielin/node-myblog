# 渡一教育-JavaScript零基础教程-姬成



[toc]

## 一、发展史 2021-01-20

Mosaic（马赛克）,是互联网历史上第一个获普遍使用和能够显示图片的网页浏览器。于1993年问世。

英语+互联网

经济是目的，金融是手段。

js是使用c语言写的。

### 浏览器历史

​	1994年4月，另克。安德森和 Silicon Graphics(简称为SGl,中译为“视算科技'或“硅图”)公司的创始人吉姆·克拉克({ Jim Clark)在美国加州设立了" Mosaic Communication Corporation"'。
​	Mosaic公司成立后，由于伊利诺伊大学拥有 Mosaic的商标权，且伊利诺伊大学已将技术转让给 Spy Glass?公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为 Netscape Navigator,公司名字于1994年11月改名为" Netscape Communication Corporation",此后沿用至今，中译为“网景”。
​	微软的 Internet Explorer及 Mozilla Firefox等，其早期版本皆以 Mosaic为基础而开发。微软随后买下 Spy Glass公司的技术开发出 Internet Explorer浏览器，而 Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。

### js历史

​	Javascript作为 Netscape Navigator 浏览器的一部分首次出现在1996年。它最初的设计目标是改善网页的用户体验。
作者： Brendan Eich
​	期初 javascript被命名为，ivescript,后因和Sun公司合作，因市场宣传需要改名Javascript。
​	后来Sun公司被Oracle收购， Javascript版权归Oracle所有。

### 浏览器组成

1. shell（贝壳）部分

   ​	视图

2. 内核部分

   - 渲染引擎（语法规则和渲染）

   - js引擎

   - 其他模块

### js引擎

​	2001年发布ie6,首次实现对is引擎的优化和分离。
​	2008年 Google发布最新浏览器Chrome,它是采用优化后的 Javascript弓擎，引擎代号V8,因能把s代码直接转化为机械码来执行，进而以速度快而闻名。
​	后 Firefox也推出了具备强大功能的js引擎。
​	Firefox3.5 TraceMonkey(对频繁执行的代码做了路径优化）。
​	Firefox4.0 JeagerMonkey。

### js逼格

解释性语言

单线程

ECMA标注一为了取得技术优势，微软推出了 Jscript,CEnvi推出 ScriptEase,与 Javascript同样可在浏览器上运行。为了统一规格javascript兼容于ECMA标准，因此也称为ECMAScript。

### js执行队列

轮转时间片，类似吃饭。

### js三大部分

ECMAScript、DOM、BOM

主流浏览器

IE				trident

Chrome	 webkit/blink

Firefox		Gecko

Opera		presto

Safari		webkit

## 二、js基本

如何引入 

内联

```js
<script></script>
```

外部      

```js
<script src=""></script>
```



结构（html）、样式（css）、行为（js）相分离，通常采用外部引入。

### js基本语法

 变量（variable） -- var

```js
var a;//变量声明
a = 100;//赋值

var b = 100;//声明变量

var a = 10,b,c = 30,d,e;//单一var
```



命名规则 

-- 数字 和 英文字母 和 _ 和 $；  

-- 开头不能为数字；

-- 不能用保留字（未来可能会有特殊含义的词）、关键字（系统中有特殊含义的词）；

### 值类型

值决定类型

原始值  

```js
//stack 栈内存
//Number String Boolean undefined null
var a = 2;//数字类型在js中默认为浮点型
var b = "hello world";
var c = true;//flase
var d = undefind;//未定义的/为赋值的
var e = null;//空 占位
```

引用值

```js
//heap 堆内存
//array Object function ...date RegExp
```



### js语句基本规则

语句后面要用分号结東 “；”

js语法错误会引发后续代码终止，但不会影响其它js代码块。

- 低级错误（语法解析错误）
  - 中文字符等
- 逻辑错误（标准错误，情有可原）
  - 未定义等

书写格式要规范，“=+/-"两边都应该有空格。

### js运算符

**运算操作符**

“ + ”

1. 数学运算、字符串连接
2. 任何数据类型加字符串都等于字符串

“ - ”，“ * ”，“ /  ”，“ % ”，“ = ”，“ () ”

优先级 ‘’ = “ 最弱，” () “优先级较高

” ++ “，” -- “，” += “，” -= “，” /= “，” **= “，” %= “

### 练习

1. 写出打印结果

```js
var a = (10 * 3 - 4 / 2 + 1) % 2,
    b = 3;
b %= a+3;
document.write(a++);
document.write("<br>");
document.write(--b);

1,2
```

2. var a=123; var b=234;请交换a,b的值

```js
var a = 123;var b = 234;
var c = a;
a = b;
b = c;
```

```js
var a = 123;var b = 234;
a = a + b;
b = a - b;
a = a - b;
```



表述能力非常重要

**比较运算符**

" > ", " < ", " == ", " >= ", " <= ", " != "

​	比较结果为boolean值

​	字符串比较的是 ASC 码

​	NaN不等于任何东西，包括自身

**逻辑运算符**

“ && ”, “ || ”, “ ! ”, 

​	运算结构为真实的值

被认定为false的值

​	undefined, null, NaN, "", 0, false 

```js
////先看第一表达式转换成布尔值得结果，如果结果为真，那么它会看第二个表达式转换为布尔值得结果，然后如果只有两个表达式的话，只看看到第二个表达式，就可以返回该表达式的值了。当第一个为假，返回第一个的值
var a = 1 && 2;
2
//找假

var num = 1 || false;
1
//找真

var a = !123;
false
//值变布尔值 再取反
```



## 三、js语句

### 条件语句

```js
if(条件){
    执行语句;
}
```

一个小例子

```js
  var score = parseInt(window.prompt('input'));    
    //90 - 100  alibaba
    //80 - 90   tencent toutiao meituan
    //70 - 80   baidu eleme xiecheng 58赶集
    //60-70     mogujie
    //60 以下    Oh my god!!!you gotta be kidding me!!!
    if(score > 90 && score <=100 ){
        document.write('alibaba');
    }else if(score > 80 && score <= 90){
        document.write('tencent');
    }else if(score > 70 && score <= 80){
        document.write('baidu');
    }else if(score > 60 && score <= 70){
        document.write('moguojie');
    }else if(score <= 60){
        document.write('Oh my god!!!you gotta be kidding me!!!');
    }else{
		document.write('error');
    }
```



### 循环语句

```js
for(var i = 0; i < 10; i ++){
    document.write(i);
}
/*	1.var i = 0;
	2.for(var i = 0; i < 10; i ++){
   		 document.write(i);
	  }
	3.i++; --> i = 1;
	4.if(i < 10){
		 document.write(i);
	}
*/
```

```js
while(i < 10){
    document.write(i);
    i ++;
}
```

```js
do{
    document.write(i);
    i ++;
}while(i < 10)
```



### 练习

1. 计算2的n次幂，n可输入，n为自然数

```js
var n = parseInt(window.prompt('input'));
var mul = 1;
for(var i = 0; i < n; i++){
    mul *= 2;
}
document.write(mul);
```

2. 计算n的阶乘，n可输入

```js
var n = parseInt(window.prompt('input'));
var mul = 1;
for(var i = 1; i <= n; i++){
	mul *= i;
}
document.write(mul);
```

3. 著名的婓波那契额数列  

   1 1 2 3 5 8 输出第n项

```js
var n = parseInt(window.prompt('input'));
var first = 1,
	second = 1,
	third;
if(n > 2){
    for(var i = 0;i < n -2; i++){
        third = first + second;
        first = second;
        second = third;
    }
	document.write(third);
}else{
	document.write(1);
}
```

4. 编写一程序，输入一个三位数的正整数，输出时反向输出如：输入456,输出654。

```js
var n = parseInt(window.prompt('input'));
var bai = (n - n % 100) / 100;
var shi = (n - n % 10) / 10 % 10;
var ge = n % 10;
document.write(ge,shi,bai);
```

5. 输入ab,c三个数字，打印出最大的。

```js
var a = parseInt(window.prompt('input'));
var b = parseInt(window.prompt('input'));
var c = parseInt(window.prompt('input'));

if(a > b){
    if(a > c){
        document.write(a);
    }else{
        document.write(c);
    }
}else{
    if(b > c){
        document.write(b);
    }else{
        document.write(c);
    }
}
```

6. 打印出100以内的质数 (只能被1和自身整除)

```js
var count = 0;
for (var i = 1; i < 100; i++) {
    for (var j = 1; j <= i; j++) {
        if (i % j == 0) {
            count++;
        }
    }
    if (count == 2) {
        document.write(i + " ");
    }
    count = 0;
}
```

Math.sqrt(i)  --  开平方

```js
//思维的拓展
//临界点 
//100 是否为质数  10*10	
//只要看10以下的数是否能被100整除，能整除，那说明另一半也能被100整除
//100的开平方数 == 10
var count = 0;
for (var i = 2; i < 100; i++) {
    for (var j = 1; j <= Math.sqrt(i); j++) {
        if (i % j == 0) {
            count++;
        }
    }
    if (count == 1) {
        document.write(i + " ");
    }
    count = 0;
}
```



### 条件语句补充

switch case

break

continue

```js
var date = window.prompt('input');
switch (date) {
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
        console.log('working');
        break;
    case "6":
    case "7":
        console.log('relaxing');
        break;
}
```



## 四、typeof，类型转换

### 初识引用值

数组 array

```js
var arr = [1,2,3,4,5,6,7,8,9];
for(var i = 0;i < arr.length; i++){
    arr[i] += 1;//数组每一位 +1
}
```

对象 object

```js
var deng ={
    lastName : "Deng",
    age : 40,
    sex : undefined,
    wife : "xiaoliu",
    father : "dengdaye",
    son : "xiaodeng",
    handsome : false
}
console.log(deng.lastName);//访问对象的属性
deng.lastName = "Old Deng";
```



### 编程形式的区别

1. 面向过程

   一步一步

2. 面向对象

   这活谁来干

### typeof() 识别数据类型

number、string、boolean、object、undefined、function

无论识别什么类型，返回的值都是字符串类型的

### 类型转换

**显式**

```js
Number(‘123’);// 把字符串“123”转为数字123返回
parseInt(‘123,16’); //转为整型，以16进制转换为10进制
parseFloat(string); //转为浮点型
String(mix); //转为字符串
Boolean(); //转为布尔值
dome.toSting(radix); //把dome转换为string;把目标转为radix进制
```

**隐式**

```js
isNaN(); 				--> 是否是NaN，隐式调用 Number();
++ /--、 +、- (一元正负)  --> Number();
+       				--> String();
-、*、/、%   			  --> Number();
&&、||、!				   --> Boolean();
< 、> 、<= 、>=		  --> Boolean();
== 、!=				   --> Boolean();
undefined == null; 		——> true
NaN == NaN;				--> false
=== 、!== 			   绝对，不发生类型转换  
```



### 练习

```js
typeof(a)
"undefined"
typeof(undefined)
"undefined"
typeof(NaN)
"number"
typeof(null)
"object"
var a = "123abc";
typeof(+a)
"number"
typeof(!!a)
"boolean"
typeof(a + "");
"string"
1 == "1";
true
NaN == NaN
false
NaN == undefined
false
"11" + 11
"1111"
1 === "1"
false
parseInt("123abc")
123
var num = 123123.345789;
num.toFixed(3)
"123123.346"
typeof(typeof(a))
"string"
```



## 五、函数 2021-01-21

高内聚，弱耦合

function --- 函数：箱子，抽象出规则，功能

###定义

函数声明

```js
function test(){}
```

函数表达式

```js
//命名函数表达式
var test = function abc(){   
    document.write('a');
}
//匿名函数表达式	---  函数表达式
var demo = function (){  
    document.write('b');
}
```



### 组成形式

```js
function sum(a,b){//形式参数 -- 形参
    var c = a + b;
    document.write(c);
}
sum(1,2);//实际参数 -- 实参 -- arguments -- [1,2] -- 实参列表
//不定参
//当数量对应时，实参与形参之间有映射关系，你变我也变。
```

** return **

-- 终止函数

-- 返回值

```js
function myNumber(target) {
    return ++target;
}
var num = myNumber(123);
console.log(typeof(num)+" "+ num);
```



### 练习

1. 写一个函数，功能是告知你所选定的小动物的叫声

```js
var animal = window.prompt('input');
scream(animal);
function scream(animal) {
    switch (animal) {
        case "dog": document.write("wang!!");
            return;
        case "cat": document.write("miao!!");
            return;
        case "fish": document.write("o~o~o~");
            return;
    }
}
```

2. 写一个函数，实现加法计数器。

```js
var a = parseInt(window.prompt('input'));
var b = parseInt(window.prompt('input'));
var c = parseInt(window.prompt('input'));
function sum() {
    var result = 0;
    for (var i = 0; i < arguments.length; i++) {
        result += arguments[i];
    }
    document.write(result);
}
sum(a, b, c);
```

3. 定义一组函数，输入数字，逆转并输出汉字形式。

```js
function reverse() {
    var num = window.prompt('input');
    var str = "";
    for (var i = num.length - 1; i >= 0; i--) {
        str += transfer(num[i]);
    }
    document.write(str);
}
function transfer(str) {
    switch (str) {
        case "1": return "壹";
        case "2": return "贰";
        case "3": return "叁";
        case "4": return "肆";
        case "5": return "伍";
        case "6": return "陸";
        case "7": return "柒";
        case "8": return "捌";
        case "9": return "玖";
    }
}
reverse();
```

4. 写一个函数，实现n的阶乘。

```js
var n = parseInt( window.prompt('input'));
//递归  n! = n * (n - 1)!
function jc(n){
    if(n == 1 || n == 0){
        return 1;
    }
    return n * jc(n -1);
}
jc(n);
//for循环
function jc1(n){
    var result  = 1;
    for(var i = 1;i <= n;i ++){
        result *= i;
    }
    document.write(result);
} 
jc1(n);

```

5. 写一个函数，实现斐波那契数列。

```js
var n = parseInt( window.prompt('input'));  
//递归
function fb(n){
    if(n == 1 || n == 2){
        return 1;
    }
    return fb(n - 1) + fb(n - 2); 
}
document.write(fb(n));

//for循环
var n = parseInt(window.prompt('input'));
var first = 1,
	second = 1,
	third;
if(n > 2){
    for(var i = 0;i < n -2; i++){
        third = first + second;
        first = second;
        second = third;
    }
	document.write(third);
}else{
	document.write(1);
}
```



### 递归

1. 找规律

   n! = n * (n - 1)!;  //阶乘

   fb(n) = fb(n - 1) + fb(n - 2); //斐波那契数列

2. 找出口

   return

递归使代码更加简洁



### 预编译初步

js运行三部曲：

1. 语法分析 

   -- 通篇扫描

2. 预编译     

   -- 函数声明 整体提升

   -- 变量 **声明**提升

3. 解释执行



### 预编译前奏：

1. imply global 暗示全局变量，即任何变量。

   如果变量未经声明就赋值，此变量为全局对象(window)所有。

   eg：a = 123;

   eg：var a = b = 123; //函数内连续赋值，b未声明就赋值，归全局所有

2. 一切声明的全局变量，全为window的属性。

   window 就是全局的域

   eg：var a = 123; --->  window.a = 123;



### 预编译

四部曲 --- 执行的前一刻

```js
function fn(a){
    console.log(a); //function a(){}
    var a = 123;
    console.log(a); //123
    function a(){}
    console.log(a); //123
    var b = function(){}
    console.log(b); //function(){}
    function d(){}
}
fn(1);
```

1. 创建AO对象。 

   Activation Object (执行期上下文)

```js
AO{

}
```

2. 找形参和变量声明，将变量名和形参名作为AO属性名，值为undefined。

```js
AO{
	a : undefined,
	b : undefined
}
```

3. 将实参值和形参相统一。

```js
AO{
	a : 1,
	b : undefined
}
```

4. 在函数体里面找函数声明，值赋予函数体。

```js
AO{
	a : function a(){},
	b : undefined,
    d : function d(){}
}
```

预编译创建完AO对象后，然后 **自上而下** 执行代码，在这一步看变量赋值部分

```js
AO{
	a : 123,
	b : function (){},
    d : function d(){}
}
```

**全局也有预编译过程**

1. 生成一个 GO对象 （Global Object）
2. 找变量声明，值为undefined。
3. 找函数声明，值赋予函数体。



### 作用域

作用域定义：変量（变量作用于又称上下文）和函数生效（能被访问）的区域

全局、局部变量

作用域的访问顺序



### 作用域精解

**[[scope]]:**

每个 javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以,

这些属性仅供javascript引擎存取，[[scope]]就是其中一个。

[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。

**作用城链:**

[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。

**运行期上下文:**

当函数执行时，会创建一个称为**执行期上下文**的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文被销毀。

**查找变量:**

从作用域链的顶端依次向下查找。

```js
function a(){
	function b(){
        function c(){

        }
        c();
    }
    b();
}
a();

//执行期上下文
//a defined a.[[scope]] -- > 0 : GO
//a doing   a.[[scope]] -- > 0 : aAO
//						   	 1 : GO
                           
//b defined b.[[scope]] -- > 0 : aAO
//						     1 : GO
//b doing   b.[[scope]] -- > 0 : bAO
//						     1 : aAO   
//                           2 : GO
                           
//c defined c.[[scope]] -- > 0 : bAO
//						     1 : aAO   
//                           2 : GO 
//c doing   c.[[scope]] -- > 0 : cAO
//						     1 : bAO   
//                           2 : aAO  
//                           3 : GO                         
```



### 闭包

当内部函数被保存到外部时，将会生成闭包。

闭包会导致原有作用域链不释放，造成**内存泄露**（抓沙子）。

内存占的越多，可用的就越少，过多占用内存资源。

```js
function a(){
	function b(){
		var bbb = 234;
        document.write(aaa);
    }
    var aaa = 123;
    return b;
}
var glob = 100;
var demo = a(); //将b函数赋给demo
demo();//123，相当于执行的是b函数
```

```js
function a(){
	var num = 100;
    function b(){
		num ++;
        console.log(num);
    }
    return b;
}
var demo = a();
demo(); //101
demo(); //102

```



### 闭包的作用

1. 实现公有变量
   eg：函数累加器

```js
function add(){
    var count = 0;
    function demo(){
        count ++;
        console.log(count);
    }
    return demo;
}
var counter = add();
counter(); //1
counter(); //2
counter(); //3
```

2. 可以做缓存（存储结构）

```js
function test(){
	var num = 100;
    function a(){
		num ++;
        console.log(num);
    }
    function b(){
        bun --;
        console.log(num);
    }
    return [a,b];
}
var myArr = test(); //定义时，a,b 共用同一个上下文
myArr[0](); //101 
myArr[1](); //100
```

​		eg： eater

```js
function eater(){
    var food = ""; //相当于一个隐式存储结构，eat，push使用同一个food
    var obj = {
		eat : function(){
            console.log("i am eating " + food);
            food = "";
        },
        push : function (myFood){
            food = myFood;
        }
    }
    return obj;
}
var eater1 = eater();
eater1.push('banana');
eater1.eat();//i am eating banana
```

3. 可以实现封装，属性私有化
   eg:：Person();

```js
function Deng(name, wife){
    var prepareWife = "xiaozhang";
    this.name = name;
    this.wife = wife;
    this.divorce = function (){
		this.wife = prepareWife;
    }
    this.changePreparWife = function(target){
        prepareWife = target; 
    }
     this.sayPreparWife = function(){
        console.log(prepareWife);
    }
}
var deng = new Dengg('deng', 'xiaoliu');

//无法通过直接访问这个变量
> deng.prepareWife 
> undefined
//但是可以通过函数内的方法去访问这个变量，形成变量的私有化
> deng.sayPreparWife
> "xiaozhang"
```



4. 模块化开发，防止污染全局变量



### 立即执行函数

针对初始化功能的函数

定义：此类函数没有声明，在一次执行过后即释放。适合做初始化工作。

```js
var num = (function (a,b,c){
    var d = a + b + c * 2 - 2;
    return d;
}(1,2.3))
```

官方给出的两种形式

```js
(function (){
	//W3C 建议使用第一种
}());

(function (){

})();
```

只有表达式才能被执行符号执行

```js
function test(){
	var a = 123;
}()//执行符号 ()
//报错：Uncaught SyntaxError: Unexpected token ')'
```

能被执行符号执行的表达式，函数名被略过

```js
+ function test(){
    console.log('a');
}();

//a
//Uncaught ReferenceError: test is not defined
```



### 闭包精细版

```js
function test(){
    var arr = [];
    for(var i = 0; i < 10; i ++){
        arr[i] = function(){
         	//只有当函数被执行时，后面的函数体才会执行
            document.write(i + " ");
        }
    }
    return arr;//形成闭包
}
var myArr = test();
for(var j = 0; j < 10; j ++){
    myArr[j]();//数组中保存的函数使用的上下文为同一个
}
//10 10 10 10 10 10 10 10 10 10
```

```js
function test(){
    var arr = [];
    for(var i = 0; i < 10; i ++){
        (function (j){
       		arr[j] = function (){
                document.write(j + " ");
            }
        }(i));//立即执行函数
    }
    return arr;//形成闭包
}
var myArr = test();
for(var j = 0; j < 10; j ++){
    myArr[j]();//数组中保存的函数使用的上下文为同一个
}
//0 1 2 3 4 5 6 7 8 9
```



### 闭包的定式

两个或多个函数互相嵌套，把里面的函数保存到外部，这样的情况，它必然会生成闭包。然后里面的函数在外面执行的时候，一定能够调用得了原来它所在的那个函数环境的变量。

### 闭包的防范
闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况发生。

## 六、对象 2021-01-22

1. 简单描述

   基础的变量类型；

   引用值；与数组和function一样

   生活中的任何物体都能抽象成一个对象，有共同的属性和方法；

```js
var mrDeng = {
	name : "MrDeng",
    age :　40,
    sex : "male",
    health : 100,
    smoke : function (){
        console.log('I am smoking ! cool!!!');
        this.health --; //this 第一人称
    },
    drink : function (){
        console.log('I am drink');
        this.health ++  ;
    }
}
```



2. 属性的增、删、改、查

属性的增

```js
mrDeng.wife = "xaowang";
```

属性的删

```js
delete mrDeng.name;
```

属性的改

```js
mrDeng.sex = "female";
```

属性的查

```js
mrDeng.sex;
```



3. 对象的创建方法

- 对象字面量/对象直接量  --  plainObject

```js
var  obj = {}
```



- 构造函数

系统自带 

new Object();    Array();    Number();    Boolean();    String();    Date();

```js
var obj = new Object();
obj.name = 'abc';
obj.sex = 'female';
obj.say = function(){
    
}
```

自定义	

```js
//构造函数 函数名应符合大驼峰是命名规则
function Car(color){
    this.colorr = color,
	this.name = "BMW";
    this.height = 1400;
    this.lang = 4900;
    this.wight = 1000;
    this.health = 100
    this.run = function (){
        this.health --;
    }
}
var car = new Car("red");
var car1 = new Car();
```



Object. create（原型）方法

###构造涵数 內部原理

1. 在函数体最前面隐式的加上 this = {}
2. 执行 this.xxx = xxx
3. 隐式的返回 this

```js
function Person(name, height){
    //var this = {} //隐式
    this.name = name;
    this.height = height;
    this.say = function (){
        console.log(this.say);
    }
    //return this; 
}
console.log(new Person('xiaowang', 180).name);
```



### 包装类

进行隐式类型转换

new Number();

```js
var num = new Number(123);

> num
> Number {123}
```

new String();

```js
var str = new String('abc');

> str
> String {"abc"}
```

new Boolean();

```js
var bol = new Boolean('true');

> bol
> Boolean {true}
```

注意：undefined 与 null 不能设置属性

原始值不能有属性和方法，但为什么能调用，经历了一个过程 “”包装类“

```js
//包装类
var num = 4;
num.len = 3;
//new Number(4).len = 3;	delete
console.log(num.len); //undefined
//new Number(4).len;
```

```js
var str = "abcd";
str.length = 2;
//new String('abcd').length = 2;	delete

console.log(str); //abcd
console.log(str.length); //4 .length 是String()这个包装类自带的
```

### 练习

```js
var x = 1, y = z = 0;
function add(n){
    return n = n + 1;
}
y = add(x);
function add(n){
    return n = n + 3;
}
z = add(x);
//x y z
//1 4 4
//注意：预编译过程，函数声明重名会覆盖，不会出现两个同名的
```



写一个方法，求一个字符串的字节长度。

（提示：字符串有一个方法 charCodeAt() ;一个中文占两个字节，一个英文占一个字节。
**定义和用法**
charCodeAt() 方法可返回指定位置的字符的 Unicode编码。

这个返回值是0-65535之间的整数。(当返回值是 <= 255时，为中文，当返回值 > 255时为英文)
**语法**
stringObject. charCodeAt(index)

eg:

```js
<script type="javascript/text>
	var str="Hello world!
	document. write(str.charCodeAt(1));//输出101
</script>
```



```js
var str = "hellow world!"

function bytesLen(str){
    var count = str.length;
    for(var i = 0; i < str.length; i ++){
        if(str.charCodeAt(i) > 255){
           	count ++;
           }
    }
    return count;
}
```



### 原型

1. 定义：原型是 function对象 的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。

```js
//Person.prototype      -- 原型
//Person.prototype = {} -- 公有祖先
Person.prototype.name = "deng";
function Person(){
    
}
var person = new Person();

> person
> Person {}
> person.name
> "deng"
```

2. 利用原型特点和概念，可以提取共有属性。

```js
Car.prototype.height = 1400;
Car.prototype.lang = 4900;
Car.prototype.carName = "BMW";

//Car.prototype = {
//    height = 1400,
//    lang = 4900,
//    carName = "BMW"
//}

function Car(color, owner){
    this.owner = owner;
    this.color = color;
}
var car = new Car('red', 'prof.ji');
var car1 = new Car('green', 'laodeng');
```



3. 对象如何查看原型 -- > 隐式属性 __ proto__ 。

```js
Person.prototype.name = 'abc';
function Person(){
    //var this = {
	//	__proto__ : Person.prototype 原型的指向
	//}
    //...
    //return this;  
}

var person = new Person();

> person.name
> 'abc'
```

__ proto __ 的基本应用

```js
Person.prototype.name = 'sunny';
function Person(){}

//Person.prototype.name = 'cherry';
var person = new Person();
Person.prototype.name = 'cherry';//在原型的基础上修改

> person.name
> 'cherry'
```

```js
Person.prototype.name = 'sunny';
function Person(){}

var person = new Person();//对象先创建
Person.prototype = { //把原型给改了，换了个新原型对象
	name = 'cherry' 
}

> person.name
> 'sunny'
```

```js
Person.prototype.name = 'sunny';
function Person(){}

Person.prototype = { //把原型给改了，换了个新原型对象
	name = 'cherry' 
}
var person = new Person();//对象后创建

> person.name
> 'cherry'
```



4. 对象如何查看对象的构造函数 -- > constructor（构造器）。

```js
function Person(){
    
}
var person = new Person();

> person.constructor
> ƒ Person() {}
//指向根据谁生成自己的，就是父辈
```



### 原型链

```js
//在原型上面再加一个原型再加一个原型的方式，把原型连成链，访问顺序也是依照链的方式，像作用域链一样去访问的东西，叫做原型链，连接点就是prototype

//Grand.prototype.__prroto__ = Object.protottype; 原型链的终端
Grand.prototype.lastName = "Deng";
function Grand(){}

var grand = new Grand();

Father.prototype = grand;
function Father(){
    this.name = 'xuming';
}

var father = new Father();

Son.prototype = father;
function Son(){
    this.hobbit = 'smoke';
}
var son = new Son();

> son.lastName
> "Deng"
```



绝大多数对象的最终都会继承自 Object.prototype

```js
//var obj = Object.create(原型);

//var obj = Object.create(null); 一个没有原型的对象
```



### call、apply

作用，改变this指向。
区别，后面传的参数形式不同。

```js
     //call
    function Person(name,age){
        //this == obj
        this.name = name;
        this.age = age;
    }
    var person = new Person('deng', 100);

    var obj = {}
    Person.call(obj, 'cheng', 300);

    > obj
    > Object{name : "cheng", age:300} //借 Person对象 来构成自己的属性
```

```js
//用别人的方法构建自己的属性
function Person(name, age, sex){
    this.name = name;
    this.age = age;
    this.sex = sex;
}
function Student(name, age, sex, tel, grade){
    //var this = {}
    Person.call(this, name, age, sex);//this指向谁？
    
    this.tel = tel;
    this.grade = grade;
}
var student = new Student('sunny', 123, 'male', 139, 2017);
```

```js
//apply
function Person(name,age){
    //this == obj
    this.name = name;
    this.age = age;
}
var person = new Person('deng', 100);

var obj = {}
Person.apply(obj, ['cheng', 300]);

> obj
> Object{name : "cheng", age:300} 
```

call 需要把实参按照形参的个数传进去

apply 需要传一个 arguments

## 七、继承 2021-01-23

### 发展史

1. 传统形式 一 > 原型链
   过多的继承了没用的属性

2. 借用构造函数
   不能继承借用构造函数的原型
   每次构造函数都要多走一个函数

   call、apply

3. 共享原型
   不能随便改动自己的原型，公用一个共有的一个原型环境

```js
Father.prototype.lastName = "deng";
function Father(){
    
}
function Son(){
    
}
Son.prototype = Father.prototype;//把Father的原型的引用值赋给Son
//inherit(Son, Father)
var son = new Son();
var father = new Father();

//封装一个继承的函数
function inherit(Target, Origin){
    Target.prototype = Origin.prototype
}
```



4. 圣杯模式

   借助一个第三方的构造函数

```js
Father.prototype.lastName = "deng";
function Father(){
    
}
function Son(){
    
}

inherit(Son, Father)
var son = new Son();
var father = new Father();

//封装一个继承的函数
function inherit(Target, Origin){
    function F(){};//第三方的构造函数
    F.prototype = Origin.prototype;
    Target.prototype = new F();
    Target.prototype.constuctor = Target; //归位，不然的话会访问到的是Father的
    //son.__proto__ -- > new F().__proto__ -- > Father.prototype
    Target.prototype.uber = Origin.prototype;
    //超类，最终继承自谁
}

//YUI3 yahoo 关于上面那种写法的修改
var inherit = (function (){
    var F = function(){}; //闭包，形成私有化
    return function (Target, Origin){
		F.prototype = Origin.prototype;
    	Target.prototype = new F();
   		Target.prototype.constuctor = Target;
    	Target.prototype.uber = Origin.prototype;
        //超类，最终继承自谁
    }
}());
```



### 命名空间

管理变量，防止污染全局，适用于模块化开发

```js
//老方法
var org = {
    department1 : {
        zhangsan : {
            name : "abc",
            age : 18
        },
        lisi : {}
    },
    department2 : {
        wangwu : {},
        zhaoliu : {}
    }
}
var zhangsan = org.department1.zhangsan;
zhangsan.name;

//新方法 采用闭包中的变量私有化 
```

### 思考问题

如何实现链式调用模式(模仿 jquery)

obj. eat().smoke().drink().eat().sleep();

```js
var deng = {
	smoke : fuunction (){
    	console.log('smoking');
		return this; //返回this，默认返回的是undefined
	}
    drink : fuunction (){
    	console.log('drinking');
		return this;
	}
	perm : fuunction (){
    	console.log('preming');
		return this;
	}
}
deng.smoke().drink().perm();
```



### 属性表示方法
obj.prop  ----- > obj["prop"]

```js
var deng = {
	wife1 : {name : 'xiaoliu'},
    wife2 : {name : 'xiaozhang'}
	sayWife : function(num){
        return this['wife' + num];//实现变量名的拼接
    }
}

```



### 对象的枚举 enumeration

1. for in

```js
var obj = {
    name : '13',
    age : 123,
    sex : 'male',
    height : 180,
    weight : 75
}

for(var prop in obj){
    //console.log(obj.prop -- > obj['proop']); //undefined
    console.log(obj[prop]);
}
```



2. hasOwnProperty

   过滤性方法

   判断是否是自身的方法，而不是原型链上的

```js
var obj = {
    name : '13',
    age : 123,
    sex : 'male',
    height : 180,
    weight : 75,
    __proto__ : {
        lastName : 'deng'
    }
}
for(var prop in obj){
    if(obj.hasOwnProperty(prop)){//是 -- true；不是 -- false
        console.log(obj[prop]);
    }
}
```



3. in

```js
height in obj;
```

​		判断一个属性是否是这个对象上的

​		能不能在这个对象上使用这个属性

4. instanceof

```js
A instanceof B;
```

​		A对象 是不是 B构造函数 构造出来的

​		看A对象的原型链上 有没有  B的原型



### 如何区分 [] || {}

```js
//var arr = {};//[]

//第一种区分方法
> [].constructor
> fuunction Array(){ [native code] }

> {}.constructor
> fuunction Object(){ [native code] }

//第二种区分方法
> [] instanceof Array
> true

> {} instanceof Array
> false

//第三种方法 toString
> Object.prototype.toString.call([]);
> "[object Array]"
> Object.prototype.toString.call({});
> "[object Object]"
> Object.prototype.toString.call(123);
> "[object Number]"
```



### this 

1. 函数预编译过程 this -- >  window
2. 全局作用域里 this -- > window
3. call / apply 可以改变函数运行时 this 指向

4. obj.func();   func() 里面的 this 指向 obj

###arguments

arguments.callee

```js
var num = (function(n){
    if(n == 1){
        return 1;
    }
    return n * arguments.callee(n - 1);//函数自身的引用
}(20))
```



func.caller

被调用的环境

```js
function test(){
    demo();
}
function demo(){
    console.log(demo.caller);
}
test();

> function test(){demo();}

//注意：在es5 "use strict";模式不允许使用
```

### 克隆

```js
//浅层克隆，原始值，引用值不好使
var obj = {
	name : 'abc',
    age : 123,
    sex : 'female'
}
var obj1 = {}
function clone(origin, target){
    var target = target || {};
    for(var prop in origin){
        target[prop] = origin[prop];
    }
    return target;
}
clone(obj, obj1);

//深层克隆，原始值，引用值
var obj = {
	name : 'abc',
    age : 123,
    sex : 'female',
    card : ['visa','unionpay'],
    wife : {
        name :　"bcd",
        son : {
            name : "a"
        }
    }
}
var obj1 = {}
//遍历对象	for(var prop in obj)
//1.判断是不是原始值	typeof() object
//2.判断是数组还是对象	instanceof  toString.call	constructor
//3.建立相应的数组或对象
//递归
function deepClone(origin, target){
    var target = target || {},
        toStr = Object.prototype.toString,
        arrStr = "[object Array]";
    for(var prop in origin){ //遍历
        if(origin.hasOwnProperty(prop)){ //判断是否是原型链上的属性
            if(origin[prop] !== "null" && typeof(origin[prop]) == 'onject'){ 
                //判断是不是原始值
                if(toStr.call(origin[prop]) == arrStr){ //判断是数组还是对象
                    target[prop] = []; //建立相应的数组
                }else{
                    target[prop] = {}; //建立相应的对象
                }
                //使用三目运算符 简化
                //target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {};
                deepClone(origin[prop], target[prop]); //递归
            }else{
                target[prop] = origin[prop];
            }
        }
    }
    return target; //如果没有用传target
}
```



### 三目运算符

条件判断 ？ 是 ： 否  并且会返回值

```js
var num = 1 > 0 ? ("10" > "9" ? 1 : 0) : 2;
> num
> 0
```



## 八、数组

### 如何创建

数组字面量

```js
var arr = [];
var arr = [1,2,3,4]
```

数组构造函数

```js
var arr = new Array();
var arr = new Array(1,2,3,4,5);
var arr = new Array(10);//只有一个参数，长度为10的空数组
```

### 读和写

arr[num] 	//不可以溢出读

arr[num] = xxx;	//可以溢出写

### 数组常用的方法

1. 改变原数组
   push, pop, shift, unshift, sort, reverse（翻转）,splice（切片）

```js
var arr = [];
arr.push(1,2,3); //在数组后面添加数据
//push方法怎么写的？系统实现
//Array.prototype.push = function(){
//    for(var i = 00; i < arguments.length; i++){
//        this[this.length] = arguments[i];
//    }
//    return this.length;
//}
arr.pop(); //将数组最后一位剪切出来

arr.shift(); //将数组第一位剪切出来
arr.unshift(0,1,2,3); //在数组前面添加数据
arr.reverse(); //翻转数组数据顺序
arr.splice(1,2); //从 第1位 为开始，截取 2 的长度
arr.splice(1,1,0,0,0); //从 第1位 开始，截取 1 的长度，在 第1位处插入
arr.splice(-1,1); //从 倒数第1位 开始，截取 1 的长度
//从第几位开始截取，截取多少的长度，在切开处添加新的数据

arr.sort(); //排序，但是默认是按照ASCII码；
arr.sort(function(a, b){
    //1.必须写俩形参
    //2.看返回值	
    //		1)当返回值为负数时，那么前面的数放在前面
    //		2)为正数，那么后面的数在前
    //		3)为0,不动
    
    return a - b; // 升序
  //return b - a; // 降序
    
    //if(a > b){
    //    return 1;
    //}else{
    //   return -1;
    //}  
});


```



2. 不改变原数组
   concat, join --- > split, toString. slice

```js
var arr = [1];
var arr1 = [2,3]
arr.concat(arr1); //把arr1 连接 在 arr 后面

arr.toString(); //把数组转换为字符串
var newArr = arr.slice(1,2);//从第1为开始，截取到第2位
//从 第几位 开始，截取到第几位
var newArr1 = arr.slice(2); //从第2位开始，截取到最后一位
var newArr2 = arr.slice(); //截取全部、

var str = arr.join("-"); //连接数组，按照上传的参数进行连接
str.split("-"); //拆分数组，按照上传的参数进行拆分
```



### 练习

给一个有序的数组，乱序

```js
var arr = [1,2,3,4,5,6,7,8];
arr.sort(function(){
    return Math.random() - 0.5;
}) 
```



### 类数组

​	属性要为索引（数字）属性，必须有 length属性，最好加上push

```js
var obj = {
    "0" : "a",
    "1" : "b",
    "2" : "c",
    "length" : 3,
    "push" : Array.prototype.push,
    "splice" : Array.prototype.splice
}
//Array.prototype.push = function(target){
//    obj[obj.length] = target;
//    obj.length ++;
//}
```

1. 可以利用属性名模拟数组的特性
2. 可以动态的增长 length 属性
3. 如果强行让类数组调用push方法，则会根据 length 属性值的位置进行属性的扩充



### type封装

```js
function type(target){
  	//1.分两类 原始值 引用值
	//2.区分引用值  
    var template = {	
            "[object Array]" : "array",
            "[object Object]" : "object",
            "[object Number]" : "number - object",
            "[object Boolean]" : "boolean - object",
            "[object String]" : "string - object 	
    }
    if(target === null){
        return "null";
    }
   if(typeof(target) == 'object'){
        //数组
        //对象
        //包装类 Object.prototype.toString
        var str = Object.prototype.toString.call(target);
        return template[str];  
    }else{
        return typeof(target);
    }
}
```



### 数组去重

一个对象不可能有两个同名的属性

```js
var arr = [1,1,1,1,2,2,2,1,2];

//var obj = {
//    1 : "abc",
//    2 : "abc"
//}
//obj[1] --> undefined;
//obj[1] --> "abc";
//obj[2] --> undefined;
//obj[2] --> undefined;

Array.prototype.unique = function (){
    var temp = {},
    	arr = [],
        len = this.length;
    for(var i = 0; i < len; i++){
        if(!temp[this[i]]){
            temp[this[i]] = "abc";
            arr.push(this[i]);
        }
    }
    
    return arr;
}
```



## 九、DOM 2021-01-24

1. DOM --> Document Obiect Model
2. DOM定义了表示和修改文档所需的方法。DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xm功能的类对象的集合。也有人称DOM是对HTML以及XML的标准编程接口。

### DOM基本操作

1. 对节点的增删改查

### 查  --  dom 对象

查看元素节点

```js
document //代表整个文档
document.getElementById(); //元素id在le8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素
document.getElementsByTagName(); //标签名
document.getElementsByName(); //需注意，只有部分标签name可生效(表单，表单元素 img,  iframe)
document.getElementsByClassName(); //类名 -- > ie8和ie8以下的ie版本中没有，可以多个class一起
document.querySelector(); //css选择器 在ie7和ie7以下的版本中没有 ，选出来的数据不是实时的
document.queryselectorall(); //css选择器 在ie7和ie7以下的版本中没有， 选出来的数据不是实时的
```

遍历节点树

```js
.parentNode //--> 父节点(最顶端的 parentNode 为 #document);
.childNodes //--> 子节点们
.firstChild //--> 第一个子节点
.lastChild //--> 最后一个子节点
.nextSibling //--> 后一个兄弟节点 
.previousSibling //--> 前一个兄弟节点
```

基于元素节点树的遍历

```js
.parentElement //-->返回当前元素的父元素节点(IE9以下不兼容)
.children //-->只返回当前元素的元素子节点
.node.childElementCount === node.children.length //当前元素节点的子元素节点个数(IE9以下不兼容)
.firstElementChild //-->返回的是第一个元素节点(IE9以下不兼容)
.lastElementChild //-->返回的是最后一个元素节点(IE9以下不兼容)
.nextElementSibling //-->返回后一个兄弟元素节点(IE9以下不兼容)
.previousElementsibling //-->返回前一个兄弟元素节点(IE9以下不兼容)
```

### 节点的类型

元素节点 —— 1

属性节点 —— 2

文本节点 —— 3

注释节点 —— 8

document —— 9

DocumentFragment —— 11

### 节点的四个属性

nodeName : 返回元素的标签名，以大写的形式表示，只读

nodeValue : Text节点或Comment节点的文本内容，可读写

nodeType : 返回该节点的类型，只读	1， 2， 3， 8， 9， 11

attributes : Element节点的属性集合，类数组

```js
function retElementChild(node){
    //从传入的节点内挑选出特定的节点
    //no children   
    var temp = {
        	length : 0,
        	push : Array.prototype.push,
        	splice : Array.prototype.splice
    	},
        child = node.childNodes,
        len = child.length;
    for(var i = 0; i < len; i++){
        if(child[i].nodeType === 1){
           	temp.push(child[i]);
           }
    }
    return temp;
}
```



### 节点的一个方法

Node.hasChildNodes();

判断有没有子节点，返回 true / false;

### 小案例

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .container {
            width: 15%;
        }
        .content {
            width: 100%;
            height: 50px;
            margin-top: 5px;
            display: none;
            border: 2px solid #008c8c;
        }
        .active {
            background-color: #008c8c;
        }
    </style>
</head>
<body>
    <!--简单的选项卡-->
    <div class="container">
        <button class="active">111</button>
        <button>222</button>
        <button>333</button>
        <div class="content" style="display: block;">111</div>
        <div class="content">222</div>
        <div class="content">333</div>
    </div>
    <script>
        var btn = document.getElementsByTagName('button');
        var div = document.getElementsByClassName('content');
        for (var i = 0; i < btn.length; i++) {
            (function (n) {
                btn[n].onclick = function () {
                    for (var j = 0; j < btn.length; j++) {
                        btn[j].className = '';
                        div[j].style.display = 'none';
                    }
                    this.className = 'active';
                    console.log(n); //闭包了
                    div[n].style.display = "block";
                }
            }(i));
        }
    </script>
</body>
</html>
```



```js
//移动的小物块 
var div =  document.createElement('div');
        document.body.appendChild(div);
        div.style.width = '100px';
        div.style.height = '100px';
        div.style.backgroundColor = 'red';
        div.style.position = 'absolute';
        div.style.left = '0';
        div.style.top = '0';
        var speed = 1;

		document.onkeydown = function(e){
            //按方向键移动
            switch (e.which) {
                case 38: div.style.top = parseInt(div.style.top) -  speed+ 'px';
                    break;//上
                case 40: div.style.top = parseInt(div.style.top) + speed + 'px';
                    break;//下
                case 37: div.style.left = parseInt(div.style.left) - speed + 'px';
                    break;//左
                case 39: div.style.left = parseInt(div.style.left) + speed + 'px';
                    break;//右
            }
        }

        var timer = setInterval(function (){
            //自动移动
            speed += speed / 7;
            div.style.left = parseInt(div.style.left) + speed + "px";
            div.style.top = parseInt(div.style.top) + speed + "px";
            if(parseInt(div.style.left) > 200 && parseInt(div.style.left) > 200){
                clearInterval(timer);
            }
        }, 50);
```



```html
<style>
    *{
        margin: 0;
        padding: 0;
    }
    li{
        box-sizing: border-box;
        float: left;
        width: 10px;
        height: 10px;
    }
    ul{
        list-style: none;
        width: 200px;
        height:200px;
    }
</style>
<script>
    	//画板
        var ul = document.createElement('ul');
        for(var i = 0; i < 400; i++){
            var li = document.createElement('li');
            li.setAttribute('img-data','0');
            ul.appendChild(li);
        }
        document.body.appendChild(ul);

        ul.onmouseover = function(e){
            var event = e || window.event;
            var target = event.target || event.srcElement;

            target.style.backgroundColor = "rgb(0, 255," + target.getAttribute('img-data') +")";
            target.setAttribute('img-data', parseInt(target.getAttribute('img-data')) + 6);
        }  
</script>
```



### DOM结构树 2021-01-25

![image-20210125100223528](images/学习笔记/image-20210125100223528.png)



### 注意

1. getElementById定义在Document.prototype上，即在Element节点上不能使用

2. getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document不能使用（xml document，Element）

3. getElementsByTagName方法定义在Document.prototype和Element.prototype上

4. HTMLDocument.prototype定义了一些常用属性，body,head分别指代HTML文档中的<body><head>标签

5. Document.prototype上定义了documentElement属性，指代文档中的根元素，在HTML文档中，它总是指代<html>元素

6. getElementsByClassName,querySelectorAll,querySelector在Document.prototype,Element.prototype类中均有定义   

   

### 练习

1. 遍历元素节点树（在原型链上编程）

   

2. 封装函数，返回元素e的第n层祖先元素节点

```js
function retParent(elem, n){
    while(elem && n){
        elem = elem.parentElement;
        n --;
    }
    return elem;
}
var i = document.getElementsByTagName('i')[0];

> retParent(i, 2);
```



3. 封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0,返回自己

```js
 function retSibiling(e, n){
     while(e && n){
         if(n > 0){
             if(e.nextElementSibling){
                 e = e.nextElementSibling;
             }else{
                 for(e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling){};
             }  
             n --;
         }else{
             if(e.previousElementSibling){
                 e = e.previousElementSibling;
             }else{
                 for(e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling){};
             }  
             n ++;
         }
     }
     return e;
 }

> retSibiling(strong, 1);
```



4. 编辑函数，封装 myChildren功能，解決以前部分浏览器的兼容性问题

```js
Element.prototype.myChildren = function(){
    var chhild = this.childNodes;
    var len = child.length;
    var arr =[];
    for(var i = 0; i < len; i++){
        if(child[i].nodeType == 1){
            arr.push(child[i]);
        }
    }
    return arr;
}
var div = document.getElementByTagName('div')[0];

> div.myChildren();
```



5. 自己封装 hasChildren()方法，不可用 children属性

```js
Element.prototype.hasChildren = function(){
    var chhild = this.childNodes;
    var len = child.length;
    for(var i = 0; i < len; i++){
        if(child[i].nodeType == 1){
           return true;
        }
    }
    return false;
}
var div = document.getElementByTagName('div')[0];

> div.hasChildren();
```



### 增

```js
document.createElement(); //创建元素节点
document.createTextNode(); //创建文本节点
document.createComment(); //创建注释节点
document.createDocumentFragmento(); //创建文档碎片节点
```

### 插

```js
PARENTNODE.appendChild(); //parentNode 父节点 剪切操作
PARENTNODE.insertBefore(a, b); //parentNode 父节点 (insert a, before b)
```

### 删

```js
parent.removeChild(); //他杀，剪切操作
child.remove(); //自尽，销毁操作
```

### 替换

```js
parent.replaceChild(new, origin); //拿 new 去替换 origin 剪切操作
```



### Element节点的属性和方法

```js
innerHTML //覆盖操作
innerText（火狐不兼容）/ textContent（老版本IE不好使）
```



```js
ele.setAttribute('id', 'only');
ele.getAttribute('id');
```



### insertAfter();

1. 封装函数 insertAfter();功能类似 insertBefore();
   提示：可忽略老版本浏览器，直接在Element.prototype上编程

```html
<div>
    <i></i>
	<b></b>
	<span></span>
</div>
<script>
    Element.prototype.insertAfter = function (targetNode, afterNode){
    var beforeNode = afterNode.nextElementSibling;
    if(beforeNode == null){
        this.appendChild(targetNode); //如果是最后一个元素
    }else{
        this.insertBefore(targetNode, beforeNode);//找到后一个兄弟元素，在它前面插入
    }
}
var div = document.getElementsByTagName('div')[0];
var b = document.getElementsByTagName('b')[0];
var span = document.getElementsByTagName('span')[0];
var p = document.createElement('p');
</script>

> div.insertAfter(p, span)
> undefined
> div
> <div>
    <i></i>
    <b></b>
    <span></span>
    <p></p>
  </div>
```



1. 将目标节点内部的节点顺序逆序。

```html
eg: <div><a></a><em></em></div>
	<div><em></em><a></a></div>

//

```



## 十、日期对象（Date） 2021-01-27

### 日期对象

是系统提供好的

```js
var date = new Date(); //返回一个当前的日期字符串
var getDate = date.getDate(); //返回 date 是 一个月的第几天 (1 ~ 31)
var getDay() = date.getDay(); //返回 date 是 一周的第几天 (0 ~ 6),0代表周日
var getMonth() = date.getMonth(); //返回 月份 (0 ~ 11)
var getFullYear() = date.getFullYear(); //返回 年份  以四位数返回
var getHours = date.getHours(); //返回 小时 (0 ~ 23) 
var getMinutes = date.getMinutes(); //返回 分钟 (0 ~ 59)
var getSeconds = date.getSeconds(); //返回 秒数 (0 ~ 59)
var getMilliseconds() = date.getMilliseconds(); //返回 毫秒 (0 ~ 999)
var getTime = date.getTime();//返回 1970-01-01 (计算机的纪元时间) 到现在的毫秒数

var setDate = date.setDate();//设置 Date 对象中月的某一天 (1 ~ 31)
//...//年份、小时、分钟、秒数、毫秒
var setTime= date.setTime(); //通过设置 毫秒数 的方式设置日期
var toString = date.toString(); //将Date对象转为字符串

```

## 十一、js定时器

```js
setInterval();
setTimeout();
clearInterval();
clearTimeout();
//全局对象 window 上的方法，内部函数 this 指向 window
//注意： setInterval("func()",1000);
setInterval(function(){},1000);
```



### 练习

```html
<!--计时器-三分钟后停止-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>计时器-三分钟后停止</title>
    <style type="text/css">
        input{
            width:50px;
            border:1px solid rgba(0,0,0,0.8);
            font-size:20px;
            font-weight:bold;
            text-align:right;
        }
    </style>
</head>
<body>
    Minute:<input type="text" value="0" >
    Second:<input type="text" value="0" >    

    <script type="text/javascript">
        var iutm = document.getElementsByTagName('input')[0];
        var iuts = document.getElementsByTagName('input')[1];        
        var min = 0,
            sec = 0;
        
        var timer = setInterval(function(){
            sec ++;
            if(sec == 60){
                sec = 0;
                min ++;
            }
            iuts.value = sec;
            iutm.value = min;
            if(min == 3){
                    clearInterval(timer);
                }
        },1000);
        
    </script>
</body>
</html>
```



## 十二、DOM基本操作

### 查看滚动条的距离

（滚动条在那个位置）

1. window. pageXOffset / pageYOffset

​		IE8及IE8以下不兼容

2. document.body.scrollLef t / scrollTop

   document.documentElement.scrollLeft / scrollTop

   IE9以下使用

   兼容性比较混乱，用时取两个值相加，因为不可能存在两个同时有值

### getScrollOffset()；

```js
//封装兼容性方法，求滚动轮滚动距离 getScrollOffset();
function getScrollOfset(){
    if(window.pageXOffset){
        return{
            x : window.pageXOffset,
            y : window.pageYOffset
        }
    }else{
		return{
            x : document.body.scrollLeft + document.docuumentElement.scrollLeft,
            y : document.body.scrollTop + document.docuumentElement.scrollTop,
        }
    }
}

> getScrollOfset()
```



### 查看视口的尺寸

1. window.innerWidth / innerHeight

   IE8及IE8以下不兼容

2. document.documentElement.clientWidth / clientHeight

   标准模式下，任意浏览器都兼容

3. document.body.clientWidth / clientHeight

   适用于怪异模式下的浏览器   怪异模式 —— > 删掉 <!DOCTYPE html>

   document.compatMode -- 查看浏览器是什么模式



### getViewportOffset();

```js
//封装兼容性方法，返回浏览器视口尺寸 getViewportOffset();
function getViewportOffset(){
    if(window.innerWidth){
        return{
			w : window.innerWidth,
            h : window.innerHeight
        }
    }else{
        if(document.compatMode == "BackCompat"){
            return{
                w : document.body.clientWidth,
                h : document.body.clientHeightt
            }
        }else{
            return{
                w : document.documentElement.clientWidth,
                h : document.documentElement.clientHeight
            }
        }
    }
}

> getViewportOffset();
```



### 查看元素的几何尺寸

domEle.getBoundingClientRect();
	兼容性很好

该方法返回一个对象，对象里面有left, top, right, bottom等属性。

Ieft 和 top 代表该元素左上角的X和Y坐标， right 和 bottom代表元素右下角的X和Y坐标

height 和 widh属性老版本IE并未实现

返回的结果并不是 “实时的”



### 查看元素的尺寸

​	dom.offsetWidth，dom.offsetHeight

​	视觉上的尺寸

### 查看元素的位置

​	dom.offsetLeft，dom.offsetTop

​	对于无定位父级的元素，返回相对文档的坐标

​	对于有定位父级的元素，返回相对最近的有定位的父级的坐标

​	dom.offsetParent

​	返回最近的有定位的父级，如无，返回body，body.offsetParent返回null

eg：求元素相对于文档的定位getElementPosition



### 让滚动条滚动

window上有三个方法：

​	scroll(x, y); , scrollTo(x, y);

​	scrollBy(x, y);

​	三个方法功能类似，用法都是将x，y坐标传入。即实现让滚动条滚动到当前位置

​	区别：scrollBy()会在之前的数据基础上做累加

### scrollBy();

```html
<!--eg：利用，自动阅读的功能-->
<style>
    div{
        width:100px;
        height:100px;
        border-radius:50%;
        font-size:40px;
        text-align:center;
        line-height:100px;
        color:#fff;
        position:fixed;
        right:50px;
        opacity:0.5;
    }
    .start{       
        background-color:green;      
        bottom:120px;
        
    }
    .stop{
        background-color:blue;
        bottom:10px;      
    }
</style>
<body>
    <!--长文本-->
    <div class = "start">Start</div>
	<div class="stop">Stop</div>   
    <script type="text/javascript">
        var start = document.getElementsByClassName('start')[0];
        var stop = document.getElementsByClassName('stop')[0];
        var timer = 0;
        var key = true;
        start.onclick = function(){
            if(key){
                timer = setInterval(function(){
                    window.scrollBy(0,10);
                },100);
                key = false;
            }
        }

        stop.onclick = function(){
            clearInterval(timer);
            key = true;
        }
    </script>   
</body>
```



## 十二、脚本化css

### 读写元素css属性

​	dom.style.prop

​	可读写 行间样式，没有兼容性问题，碰到float这样的保留字属性，前面应加css

​	eg：float——cssFloat

​	复合属性必须拆解，组合单词变成小驼峰式写法

​	写入的值必须是字符串格式

### 查询计算样式

​	window.getComoutedStyle(ele,null);

​	最终样式，按权重

​	ele：元素；null：可以获取伪元素

​	计算样式只读

​	返回的计算样式的值都是绝对值，没有相对单位

​	IE8与IE8以下不兼容

### 查询样式

​	ele.currentStyle --> CSSStyleDeclaration;

​	计算样式只读

​	返回的计算样式的值不是经过转换的绝对值

​	IE独有的属性

### getStyle(elem, prop);

```js
//eg：封装兼容性方法，getStyle(elem, prop)
function getStyle(elem, prop){
    if(window.getComputedStyle){
        return window.getComputedStyle(elem, null)[prop];
    }else{
        return elem.currentStyle[prop];
    }
}
```



### 练习

让小方块动起来

```html
<div style = "width:100px;height:100px;background-color:red;position:absolute;left:0;top:0;"></div>
<script>
	var div = document.getElementsByTagName('div')[0];
    setInterval(function(){
        div.style.left = parseInt(getStyle(div, 'left')) + 1 + 'px';
        if(parseInt(div.style.left) > 500){
            clearInterval(timer);
        }
    },100);
</script>
```



## 十三、事件

1. 何为事件
2. 重要吗？一交互体验的核心功能
3. 演示demo一拖拽和点击

### 如何绑定事件处理函数

1. ele.onxxx = function(event){}

   兼容性很好，但是一个元素的同一个事件上只能绑定一个处理程序

   基本等同于写在HTML行间上

2. obj.addEventListener(‘type’, fn, false);

  IE9以下不兼容，可以为一个事件绑定多个处理程序

3. obj. attachEvent('on'+ type, fn);

   IE独有，一个事件同样可以绑定多个处理程序

小练习：参见神马笔试题

```html
<ul>
    <li>a</li>
    <li>a</li>
    <li>a</li>
    <li>a</li>
</ul>
<!--使用原生js, addeventlistener,给每个li元素绑定一个c1ick事件输出他们的顺序 -->
<script>
	var liCol = document.getElementsByTagName('li'),len = liCol.length;
    for(var i = 0; i < len; i++){
        (function(i){
            liCol[i].addEventListener('click',function(){
                console.log(i);
            },false);
        }(i))
    }
</script>

```



### 事件处理程序的运行环境

1. ele.onxxx = function(event){}

   程序this指向dom元素本身

2. obj.addEventListener(type,fn,false); 

   程序this指向dom元素本身

3. obj.attachEvent(‘on’+type,fn);

   程序this指向window

封装兼容性方法：

### addEvent(elem,type,handle);

```js
function addEvent(elem, type, handle){
	if(elem.addEventListener){
        elem.addEventListener(type, handle, false);
    }else if(elem.attachEvent){
        elem.attachEvent('on' + type, function(){
            handle.call(elem);
        })
    }else{
        elem['on' + type] = handle;
    }
}
```



### 解除事件处理程序

ele.onclick = false / ''  / null;

ele.removeEventListener(type, fn, false);

ele.detachEvent('on'+type, fn);

注：若绑定匿名函数，则无法解除

封装兼容性方法：

### removeEvent(elem,type,handle);

```js
function removeEvent(elem, type, handle) {
    if (elem.removeEventListener) {
        elem.removeEventListener(type, handle, false);
    } else if (elem.detachEvent) {
        elem.detachEvent('on' + type, function () {
            handle.call(elem);
        })
    } else {
        elem['on' + type] = null;
    }
}
```



### 事件处理模型一事件冒泡、捕获

事件冒泡：
	结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）
事件捕获：
	结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自顶向下）
	IE没有捕获事件

触发顺序，先捕获，后冒泡

focus, blur,  change, submit, reset, select 等事件不冒泡



### 取消冒泡和阻止默认事

取消冒泡：

​	W3C标准 event.stopPropagation(); 但不支持ie9以下版本

​	IE独有 event.cancelBubble=true;

封装取消冒泡的函数 

### stopBubble(event);

```js
function stopBubble(event){
    if(event.stopPropagation){
        event.stopPropagation();
    }else{
        event.cancelBubble = true;
    }
}
```



阻止默认事件：

​	默认事件 一 表单提交，a标签跳转，右键菜单等

1. return false; 以对象属性的方式注册的事件才生效
2. event.preventDefault; W3C标注，IE9以下不兼容
3. event.returnValue = false; 兼容lE

封装阻止默认事件的函数 

### cancelHandler(event);

```js
function cancelHandler(event){
    if(event.preventDefault){
        event.preventDefault();
    }else{
        event.returnValue  = false;
    }
}
```



### 事件对象

event || window.event 用于IE

事件源对象
	event.target 火狐只有这个
	event.srcElement  IE只有这个
	这俩 chrome都有

兼容性写法

```js
var event = e || window.event;
var target = event.target || event.srcElement;
```



### 事件委托

利用事件冒泡， 和事件源对象进行处理

优点：

1. 性能 不需要循环所有的元素一个个绑定事件
2. 灵活 当有新的子元素时不需要重新绑定事件



```html
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>
<script>
	var ul = document.getElementsByTagName('ul')[0];
    ul.onclick = fuunction(e){
        var event = e || window.event;
        var target = event.target || event.srcElement;
        console.log(target.innerText);
    }
</script>
```



### 事件分类

鼠标事件
click、 mousedown、 mousemove、 mouseup、contextmenu、 mouseover、 mouseout、mouseenter、 mouseleave

用 button来区分鼠标的按键，0/1/2

DOM3标准规定： click事件只能监听左键，只能通过mousedown 和 mouseup来判断鼠标键

如何解決 mousedown 和 click的冲突 -- 时间戳



### 事件练习
拖拽应用

应用 mousedown mousemove mouseup

随机移动的方块

mouseover

### 拖拽

```html
<div style="width:100px;height:100px;background:#ccc;position:absolute;left:0;top:0;">
    </div>
<script>
var div = document.getElementsByTagName('div')[0];
        function drag(elem) {
            var disX,
                disY;
            div.onmousedown = function (e) {
                disX = e.pageX - parseInt(div.style.left);
                disY = e.pageY - parseInt(div.style.top);
                document.onmousemove = function (e) {
                   var event = e || window.event;
                   console.log(e.pageX + " " + e.pageY);
                   div.style.left = e.pageX - disX + "px";
                   div.style.top = e.pageY - disY + "px";
              	}
                document.onmouseup = function () {
                   document.onmousemove = null;
                }
             }
</script>
```



### 键盘事件

keydown ， keyup ， keypress.

keydown > keypress > keyup

keydown 和 keypress的区别

​	keydown 可以响应任意键盘按键， keypress只可以相应字符类键盘按键

​	keypress返回ASC码，可以转换成相应字符

​	String.fromCharCode(e.charCode);把ASCII码转换为相应的字符

### 文本操作事件

input（输入改变时触发）

change（失去焦点时，内容改变时触发）

focus, blur



### 窗体操作类( window上的事件)

scroll  

​	滚动条滚动时 触发

load（效率低）



domTree

cssTree

renderTree



小练习：fxed定位js兼容版

### fxed定位js兼容版





## JSON

JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的）

JSON.parse(); string  -->  json

JSON.stringify();  json -->  string

domt ree + csstree = randertree 

reflow 重排 dom节点的删除，添加
			dom 节点的宽高变化，位置变化， display none --> bock     offsetwidth offsetleft

repaint 重绘

## 异步加载js

js加载的缺点：加载工具方法没必要阻塞文档，过得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。

有些工具方法需要按需加载，用到再加载，不用不加载。

javascript异步加载 的 三种方案
1. defer 异步加载，但要等到dom文档全部解析完才会被执行。只有IE能用，也可以将代码写到内部

2. async 异步加载，加载完就执行， async.只能加载外部脚本，不能把js写在 script标签里。
   1.2执行时也不阻塞页面
3. 创建 script,插入到DOM中，加载完毕后 callback,

## js加载时间线

1. 创津 Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加 Element对象和Text节点到文植中。这个阶段 document.readystate='loading'
2. 遇到Iink外部css,创建线程加载，并继续解析文档
3. 遇到 script外部js,并且没有设置 async、 defer, 浏览器加载，井阻塞，等待js加载完成并执行该脚本，然后续解析文档
4. 遇到 script外部js,并且设置有 async、 defer, 浏览器创建线程加截，井继续解析文档对于 async属性的脚本，脚本加载完成后立即执行。(异步禁止使用 document. write()）
5. 遇到img等，先正常解析dom结构，然后览器异步加载srC,并续解析文档
6. 当文档解析完成， document. readystate=' interactive'
7. 文档解析完成后，所有设置有 defert的脚本会按照顺序执行。(注意与 async的不同，但同样止使用 document, write()）
8.  document对象触发 DomcontentLoaded事件，这也标志着程序执行从同步本执行阶段，转化为事件动阶段
9. 当所有 async的本加載完成井执行后、img等加完成后， document. readystate=' complete', window对象发load事件
10. 从此，以异步响应方式处理用户输入、网络事件等



## try...catch 和 严格模式 2021-01-24

### try...catch

```js
try{
    
}catch(e){
    
}finally{
    
}
//在try里面的发生错误，不会执行错误后的try里面的代码
//catch 捕捉错误  error.message  error.name --> error
```

Error.name 的六种值对应的信息：

1. EvalError : eval()的使用与定义不一致
2. RangeError : 数值越界
3. ReferenceError : 非法或不能识别的引用数值
4. SyntaxError : 发生语法解析错误
5. TypeError : 操作数类型错误
6. URIError : URI处理函数使用不当

### es5.0严格模式

```js
"use strict"
//es5.0严格模式 
//es3.0和es5.0 产生冲突的部分就是用 es5.0,否则会用 es3.0
```

不再兼容es3的一些不规则语法。使用全新的es5规范。

两种用法

​	全局严格模式，在文档的最顶端  —— “use strict”

​	局部函数内严格模式（推荐），在函数的最顶端  —— “use strict”

就是一行字符串，不会对不兼容严格模式的浏览器产生影响。

不支持 with ，arguments.callee，func.caller，变量赋值前必须声明，局部 this 必须被赋值( Person. call(null/undefined）赋值什么就是什么)，拒绝重复属性和参数。

## 正则表达式


























































